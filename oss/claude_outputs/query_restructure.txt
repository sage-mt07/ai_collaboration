# Queryå±¤æ§‹é€ åˆ†å‰² - å®Ÿè£…è¨ˆç”»

## ğŸ“¦ æ–°ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ 

```
src/Query/
â”œâ”€â”€ Abstractions/
â”‚   â”œâ”€â”€ IQueryTranslator.cs      âœ… æ–°è¦ä½œæˆ
â”‚   â”œâ”€â”€ IEventSet<T>.cs          âœ… æ–°è¦ä½œæˆ  
â”‚   â””â”€â”€ IKsqlBuilder.cs          âœ… æ–°è¦ä½œæˆ
â”œâ”€â”€ Translation/
â”‚   â”œâ”€â”€ LinqExpressionAnalyzer.cs âœ… æ—¢å­˜åˆ†å‰²
â”‚   â”œâ”€â”€ KsqlQueryBuilder.cs      âœ… æ—¢å­˜åˆ†å‰²
â”‚   â””â”€â”€ QueryDiagnostics.cs      âœ… æ–°è¦ä½œæˆ
â”œâ”€â”€ EventSets/
â”‚   â”œâ”€â”€ EventSetCore<T>.cs       âœ… æ—¢å­˜åˆ†å‰²
â”‚   â”œâ”€â”€ EventSetStreaming<T>.cs  âœ… æ—¢å­˜åˆ†å‰²
â”‚   â””â”€â”€ EventSetValidation<T>.cs âœ… æ—¢å­˜åˆ†å‰²
â””â”€â”€ Builders/
    â”œâ”€â”€ SelectBuilder.cs         âœ… ç§»å‹•
    â”œâ”€â”€ JoinBuilder.cs           âœ… ç§»å‹•
    â”œâ”€â”€ WindowBuilder.cs         âœ… ç§»å‹•
    â”œâ”€â”€ GroupByBuilder.cs        âœ… ç§»å‹•
    â”œâ”€â”€ HavingBuilder.cs         âœ… ç§»å‹•
    â””â”€â”€ ProjectionBuilder.cs     âœ… ç§»å‹•
```

## ğŸ§© åˆ†å‰²å®Ÿè£…æ‰‹é †

### 1ï¸âƒ£ Abstractionså±¤ - å…±é€šã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```csharp
// src/Query/Abstractions/IQueryTranslator.cs
using System;
using System.Linq.Expressions;

namespace KsqlDsl.Query.Abstractions
{
    /// <summary>
    /// LINQå¼ã‹ã‚‰KSQLæ–‡ã¸ã®å¤‰æ›è²¬å‹™ã‚’å®šç¾©
    /// è¨­è¨ˆç†ç”±ï¼šå¤‰æ›ãƒ­ã‚¸ãƒƒã‚¯ã®æŠ½è±¡åŒ–ã€ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š
    /// </summary>
    public interface IQueryTranslator
    {
        /// <summary>
        /// LINQå¼ã‚’KSQLæ–‡ã«å¤‰æ›
        /// </summary>
        /// <param name="expression">LINQå¼æœ¨</param>
        /// <param name="topicName">å¯¾è±¡ãƒˆãƒ”ãƒƒã‚¯å</param>
        /// <param name="isPullQuery">Pull Queryåˆ¤å®š</param>
        /// <returns>KSQLæ–‡å­—åˆ—</returns>
        string ToKsql(Expression expression, string topicName, bool isPullQuery = false);
        
        /// <summary>
        /// å¤‰æ›è¨ºæ–­æƒ…å ±å–å¾—
        /// </summary>
        string GetDiagnostics();
        
        /// <summary>
        /// Pull Queryåˆ¤å®š
        /// </summary>
        bool IsPullQuery();
    }
}

// src/Query/Abstractions/IEventSet.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;

namespace KsqlDsl.Query.Abstractions
{
    /// <summary>
    /// EventSetæ“ä½œã®å…±é€šã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
    /// è¨­è¨ˆç†ç”±ï¼šEventSetåˆ†å‰²ã«å¯¾ã™ã‚‹çµ±ä¸€API
    /// </summary>
    public interface IEventSet<T> : IQueryable<T>, IAsyncEnumerable<T> where T : class
    {
        // Core Operations
        Task AddAsync(T entity, CancellationToken cancellationToken = default);
        Task AddRangeAsync(IEnumerable<T> entities, CancellationToken cancellationToken = default);
        
        // Query Operations  
        List<T> ToList();
        Task<List<T>> ToListAsync(CancellationToken cancellationToken = default);
        string ToKsql(bool isPullQuery = false);
        
        // Streaming Operations
        void Subscribe(Action<T> onNext, CancellationToken cancellationToken = default);
        Task SubscribeAsync(Func<T, Task> onNext, CancellationToken cancellationToken = default);
        Task ForEachAsync(Func<T, Task> action, TimeSpan timeout = default, CancellationToken cancellationToken = default);
        
        // LINQ Extensions
        IEventSet<T> Where(Expression<Func<T, bool>> predicate);
        IEventSet<TResult> Select<TResult>(Expression<Func<T, TResult>> selector);
        IEventSet<IGrouping<TKey, T>> GroupBy<TKey>(Expression<Func<T, TKey>> keySelector);
        IEventSet<T> Take(int count);
        IEventSet<T> Skip(int count);
        
        // Metadata Access
        string GetTopicName();
        KsqlDsl.Modeling.EntityModel GetEntityModel();
        KafkaContext GetContext();
    }
}

// src/Query/Abstractions/IKsqlBuilder.cs
using System;
using System.Linq.Expressions;

namespace KsqlDsl.Query.Abstractions
{
    /// <summary>
    /// KSQLæ§‹æ–‡ãƒ“ãƒ«ãƒ€ãƒ¼ã®å…±é€šã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
    /// è¨­è¨ˆç†ç”±ï¼šå„ãƒ“ãƒ«ãƒ€ãƒ¼ã‚¯ãƒ©ã‚¹ã®çµ±ä¸€ã€è²¬å‹™æ˜ç¢ºåŒ–
    /// </summary>
    public interface IKsqlBuilder
    {
        /// <summary>
        /// å¼æœ¨ã‹ã‚‰KSQLæ§‹æ–‡ã‚’æ§‹ç¯‰
        /// </summary>
        /// <param name="expression">å¯¾è±¡å¼æœ¨</param>
        /// <returns>KSQLæ§‹æ–‡æ–‡å­—åˆ—</returns>
        string Build(Expression expression);
        
        /// <summary>
        /// ãƒ“ãƒ«ãƒ€ãƒ¼ç¨®åˆ¥è­˜åˆ¥
        /// </summary>
        KsqlBuilderType BuilderType { get; }
    }
    
    /// <summary>
    /// ãƒ“ãƒ«ãƒ€ãƒ¼ç¨®åˆ¥åˆ—æŒ™
    /// </summary>
    public enum KsqlBuilderType
    {
        Select,
        Where, 
        GroupBy,
        Having,
        Join,
        Window,
        Projection
    }
}
```

### 2ï¸âƒ£ Translationå±¤ - å¤‰æ›ãƒ­ã‚¸ãƒƒã‚¯åˆ†å‰²

```csharp
// src/Query/Translation/LinqExpressionAnalyzer.cs
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using KsqlDsl.Query.Abstractions;

namespace KsqlDsl.Query.Translation
{
    /// <summary>
    /// LINQå¼æœ¨ã®æ§‹æ–‡è§£æ
    /// è¨­è¨ˆç†ç”±ï¼šLinqToKsqlTranslatorã‹ã‚‰å¼æœ¨è§£æè²¬å‹™ã‚’åˆ†é›¢
    /// </summary>
    public class LinqExpressionAnalyzer : ExpressionVisitor
    {
        private readonly List<MethodCallExpression> _methodCalls = new();
        private readonly HashSet<string> _aggregateMethods = new();
        private bool _hasGroupBy = false;
        private bool _hasJoin = false;
        private bool _hasWindow = false;
        
        public LinqExpressionAnalyzer()
        {
            InitializeAggregateMethods();
        }
        
        /// <summary>
        /// å¼æœ¨ã‚’è§£æã—ã¦ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
        /// </summary>
        public ExpressionAnalysisResult Analyze(Expression expression)
        {
            // çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
            _methodCalls.Clear();
            _hasGroupBy = _hasJoin = _hasWindow = false;
            
            // å¼æœ¨è¨ªå•
            Visit(expression);
            
            return new ExpressionAnalysisResult
            {
                MethodCalls = _methodCalls.ToList(),
                HasGroupBy = _hasGroupBy,
                HasJoin = _hasJoin, 
                HasWindow = _hasWindow,
                HasAggregation = _methodCalls.Any(mc => _aggregateMethods.Contains(mc.Method.Name)),
                QueryType = DetermineQueryType()
            };
        }
        
        protected override Expression VisitMethodCall(MethodCallExpression node)
        {
            _methodCalls.Add(node);
            
            switch (node.Method.Name)
            {
                case "GroupBy":
                    _hasGroupBy = true;
                    break;
                case "Join":
                    _hasJoin = true;
                    break;
                case "Window":
                case "TumblingWindow":
                case "HoppingWindow":
                case "SessionWindow":
                    _hasWindow = true;
                    break;
            }
            
            return base.VisitMethodCall(node);
        }
        
        private void InitializeAggregateMethods()
        {
            var methods = new[] { "Sum", "Count", "Max", "Min", "Average", "Avg", 
                                "LatestByOffset", "EarliestByOffset", "CollectList", "CollectSet" };
            foreach (var method in methods)
            {
                _aggregateMethods.Add(method);
            }
        }
        
        private QueryType DetermineQueryType()
        {
            if (_hasJoin) return QueryType.Join;
            if (_hasGroupBy || _aggregateMethods.Any(m => _methodCalls.Any(mc => mc.Method.Name == m)))
                return QueryType.Aggregate;
            if (_hasWindow) return QueryType.Windowed;
            
            return QueryType.Simple;
        }
    }
    
    /// <summary>
    /// å¼æœ¨è§£æçµæœ
    /// </summary>
    public class ExpressionAnalysisResult
    {
        public List<MethodCallExpression> MethodCalls { get; set; } = new();
        public bool HasGroupBy { get; set; }
        public bool HasJoin { get; set; }
        public bool HasWindow { get; set; }
        public bool HasAggregation { get; set; }
        public QueryType QueryType { get; set; }
    }
    
    public enum QueryType
    {
        Simple,
        Aggregate, 
        Join,
        Windowed
    }
}

// src/Query/Translation/KsqlQueryBuilder.cs
using System;
using System.Linq.Expressions;
using System.Text;
using KsqlDsl.Query.Abstractions;
using KsqlDsl.Query.Builders;

namespace KsqlDsl.Query.Translation
{
    /// <summary>
    /// KSQLæ§‹æ–‡æ§‹ç¯‰ãƒ­ã‚¸ãƒƒã‚¯
    /// è¨­è¨ˆç†ç”±ï¼šLinqToKsqlTranslatorã‹ã‚‰æ§‹æ–‡æ§‹ç¯‰è²¬å‹™ã‚’åˆ†é›¢
    /// </summary>
    public class KsqlQueryBuilder
    {
        private readonly IKsqlBuilder _selectBuilder;
        private readonly IKsqlBuilder _joinBuilder;
        private readonly IKsqlBuilder _groupByBuilder;
        private readonly IKsqlBuilder _havingBuilder;
        private readonly IKsqlBuilder _windowBuilder;
        private readonly IKsqlBuilder _projectionBuilder;
        
        public KsqlQueryBuilder()
        {
            _selectBuilder = new SelectBuilder();
            _joinBuilder = new JoinBuilder();
            _groupByBuilder = new GroupByBuilder();
            _havingBuilder = new HavingBuilder();
            _windowBuilder = new WindowBuilder();
            _projectionBuilder = new ProjectionBuilder();
        }
        
        /// <summary>
        /// è§£æçµæœã‹ã‚‰KSQLæ–‡ã‚’æ§‹ç¯‰
        /// </summary>
        public string BuildQuery(ExpressionAnalysisResult analysisResult, string topicName, bool isPullQuery)
        {
            var query = new StringBuilder();
            
            // SELECTå¥æ§‹ç¯‰
            BuildSelectClause(query, analysisResult);
            
            // FROMå¥
            query.Append($" FROM {topicName}");
            
            // WHEREå¥ã€GROUP BYå¥ç­‰ã®æ§‹ç¯‰
            BuildQueryClauses(query, analysisResult);
            
            // EMITå¥åˆ¶å¾¡
            if (!isPullQuery)
            {
                query.Append(" EMIT CHANGES");
            }
            
            return query.ToString();
        }
        
        private void BuildSelectClause(StringBuilder query, ExpressionAnalysisResult result)
        {
            var selectCall = result.MethodCalls.LastOrDefault(mc => mc.Method.Name == "Select");
            
            if (selectCall != null)
            {
                if (result.HasAggregation)
                {
                    // é›†ç´„ã‚¯ã‚¨ãƒªã®å ´åˆã¯ç‰¹åˆ¥å‡¦ç†
                    query.Append(BuildAggregateSelect(selectCall));
                }
                else
                {
                    query.Append(_projectionBuilder.Build(selectCall));
                }
            }
            else
            {
                query.Append("SELECT *");
            }
        }
        
        private void BuildQueryClauses(StringBuilder query, ExpressionAnalysisResult result)
        {
            // WHEREå¥
            var whereCall = result.MethodCalls.FirstOrDefault(mc => mc.Method.Name == "Where");
            if (whereCall != null)
            {
                // å®Ÿè£…è©³ç´°ã¯æ—¢å­˜KsqlConditionBuilderã‚’æ´»ç”¨
                query.Append(" ").Append(BuildWhereClause(whereCall));
            }
            
            // GROUP BYå¥
            if (result.HasGroupBy)
            {
                var groupByCall = result.MethodCalls.First(mc => mc.Method.Name == "GroupBy");
                query.Append(" ").Append(_groupByBuilder.Build(groupByCall));
            }
            
            // JOINå¥å‡¦ç†
            if (result.HasJoin)
            {
                var joinCall = result.MethodCalls.First(mc => mc.Method.Name == "Join");
                // JOINã®å ´åˆã¯æ§‹æ–‡å…¨ä½“ã‚’å†æ§‹ç¯‰
                return; // åˆ¥é€”å®Ÿè£…
            }
        }
        
        private string BuildAggregateSelect(Expression selectExpression)
        {
            // æ—¢å­˜KsqlAggregateBuilderã‚’æ´»ç”¨
            return KsqlDsl.Ksql.KsqlAggregateBuilder.Build(selectExpression);
        }
        
        private string BuildWhereClause(Expression whereExpression)
        {
            // æ—¢å­˜KsqlConditionBuilderã‚’æ´»ç”¨
            var conditionBuilder = new KsqlDsl.Ksql.KsqlConditionBuilder();
            return conditionBuilder.Build(whereExpression);
        }
    }
}

// src/Query/Translation/QueryDiagnostics.cs
using System;
using System.Collections.Generic;
using System.Text;

namespace KsqlDsl.Query.Translation
{
    /// <summary>
    /// ã‚¯ã‚¨ãƒªè¨ºæ–­ãƒ»ãƒ‡ãƒãƒƒã‚°æƒ…å ±ç®¡ç†
    /// è¨­è¨ˆç†ç”±ï¼šãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ãƒ»ç”Ÿæˆãƒ­ã‚°ã®è²¬å‹™åˆ†é›¢
    /// </summary>
    public class QueryDiagnostics
    {
        private readonly List<string> _analysisSteps = new();
        private readonly Dictionary<string, object> _metadata = new();
        private DateTime _startTime;
        private TimeSpan _analysisTime;
        
        public QueryDiagnostics()
        {
            _startTime = DateTime.UtcNow;
        }
        
        /// <summary>
        /// è§£æã‚¹ãƒ†ãƒƒãƒ—ã‚’è¨˜éŒ²
        /// </summary>
        public void LogStep(string step, object? detail = null)
        {
            var timestamp = DateTime.UtcNow.ToString("HH:mm:ss.fff");
            var message = $"[{timestamp}] {step}";
            
            if (detail != null)
            {
                message += $": {detail}";
            }
            
            _analysisSteps.Add(message);
        }
        
        /// <summary>
        /// ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è¨­å®š
        /// </summary>
        public void SetMetadata(string key, object value)
        {
            _metadata[key] = value;
        }
        
        /// <summary>
        /// è§£æå®Œäº†ãƒãƒ¼ã‚¯
        /// </summary>
        public void MarkComplete()
        {
            _analysisTime = DateTime.UtcNow - _startTime;
            LogStep($"Analysis completed in {_analysisTime.TotalMilliseconds:F2}ms");
        }
        
        /// <summary>
        /// è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
        /// </summary>
        public string GenerateReport()
        {
            var report = new StringBuilder();
            
            report.AppendLine("=== KSQL Query Diagnostics ===");
            report.AppendLine($"Analysis Duration: {_analysisTime.TotalMilliseconds:F2}ms");
            report.AppendLine();
            
            // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›
            if (_metadata.Count > 0)
            {
                report.AppendLine("Metadata:");
                foreach (var kvp in _metadata)
                {
                    report.AppendLine($"  {kvp.Key}: {kvp.Value}");
                }
                report.AppendLine();
            }
            
            // ã‚¹ãƒ†ãƒƒãƒ—å±¥æ­´
            report.AppendLine("Analysis Steps:");
            foreach (var step in _analysisSteps)
            {
                report.AppendLine($"  {step}");
            }
            
            return report.ToString();
        }
        
        /// <summary>
        /// ç°¡æ½”ã‚µãƒãƒª
        /// </summary>
        public string GetSummary()
        {
            var queryType = _metadata.TryGetValue("QueryType", out var qt) ? qt : "Unknown";
            var isPullQuery = _metadata.TryGetValue("IsPullQuery", out var pq) ? pq : false;
            
            return $"Query: {queryType}, Pull: {isPullQuery}, Time: {_analysisTime.TotalMilliseconds:F1}ms";
        }
    }
}
```

### 3ï¸âƒ£ EventSetså±¤ - EventSetåˆ†å‰²

```csharp
// src/Query/EventSets/EventSetCore.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;
using KsqlDsl.Modeling;
using KsqlDsl.Query.Abstractions;

namespace KsqlDsl.Query.EventSets
{
    /// <summary>
    /// EventSetåŸºæœ¬CRUDæ“ä½œ
    /// è¨­è¨ˆç†ç”±ï¼šEventSet.csã‹ã‚‰åŸºæœ¬æ“ä½œè²¬å‹™ã‚’åˆ†é›¢
    /// </summary>
    public partial class EventSetCore<T> : IEventSet<T> where T : class
    {
        protected readonly KafkaContext _context;
        protected readonly EntityModel _entityModel;
        protected readonly IQueryProvider _queryProvider;
        protected readonly Expression _expression;

        internal EventSetCore(KafkaContext context, EntityModel entityModel)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
            _entityModel = entityModel ?? throw new ArgumentNullException(nameof(entityModel));
            _queryProvider = new EventQueryProvider<T>(context, entityModel);
            _expression = Expression.Constant(this);
        }

        internal EventSetCore(KafkaContext context, EntityModel entityModel, Expression expression)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
            _entityModel = entityModel ?? throw new ArgumentNullException(nameof(entityModel));
            _queryProvider = new EventQueryProvider<T>(context, entityModel);
            _expression = expression ?? throw new ArgumentNullException(nameof(expression));
        }

        // IQueryableå®Ÿè£…
        public Type ElementType => typeof(T);
        public Expression Expression => _expression;
        public IQueryProvider Provider => _queryProvider;

        // åŸºæœ¬è¿½åŠ æ“ä½œ
        public async Task AddAsync(T entity, CancellationToken cancellationToken = default)
        {
            if (entity == null)
                throw new ArgumentNullException(nameof(entity));

            ValidateEntity(entity);

            var producerService = _context.GetProducerService();
            await producerService.SendAsync(entity, _entityModel, cancellationToken);

            if (_context.Options.EnableDebugLogging)
            {
                var topicName = _entityModel.TopicAttribute?.TopicName ?? _entityModel.EntityType.Name;
                Console.WriteLine($"[DEBUG] EventSetCore.AddAsync: {typeof(T).Name} â†’ Topic: {topicName} (é€ä¿¡å®Œäº†)");
            }
        }

        public async Task AddRangeAsync(IEnumerable<T> entities, CancellationToken cancellationToken = default)
        {
            if (entities == null)
                throw new ArgumentNullException(nameof(entities));

            var entityList = entities.ToList();
            if (entityList.Count == 0)
                return;

            // å…¨ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®äº‹å‰ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            foreach (var entity in entityList)
            {
                ValidateEntity(entity);
            }

            var producerService = _context.GetProducerService();
            await producerService.SendRangeAsync(entityList, _entityModel, cancellationToken);

            if (_context.Options.EnableDebugLogging)
            {
                var topicName = _entityModel.TopicAttribute?.TopicName ?? _entityModel.EntityType.Name;
                Console.WriteLine($"[DEBUG] EventSetCore.AddRangeAsync: {entityList.Count}ä»¶ã®{typeof(T).Name} â†’ Topic: {topicName} (é€ä¿¡å®Œäº†)");
            }
        }

        // IEnumerableå®Ÿè£…
        public IEnumerator<T> GetEnumerator()
        {
            return ToList().GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        // IAsyncEnumerableå®Ÿè£…
        public async IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            await Task.Delay(1, cancellationToken);

            var items = ToList();
            foreach (var item in items)
            {
                if (cancellationToken.IsCancellationRequested)
                    yield break;

                yield return item;
            }
        }

        // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹
        public EntityModel GetEntityModel() => _entityModel;
        public KafkaContext GetContext() => _context;
        public string GetTopicName() => _entityModel.TopicAttribute?.TopicName ?? _entityModel.EntityType.Name;

        // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå…±é€šï¼‰
        protected virtual void ValidateEntity(T entity)
        {
            if (entity == null)
                throw new ArgumentNullException(nameof(entity));

            // åŸºæœ¬çš„ãªã‚­ãƒ¼ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
            if (_entityModel.KeyProperties.Length > 0)
            {
                foreach (var keyProperty in _entityModel.KeyProperties)
                {
                    var keyValue = keyProperty.GetValue(entity);
                    if (keyValue == null)
                    {
                        throw new InvalidOperationException(
                            $"Key property '{keyProperty.Name}' cannot be null for entity type '{typeof(T).Name}'");
                    }

                    if (keyProperty.PropertyType == typeof(string) && string.IsNullOrEmpty((string)keyValue))
                    {
                        throw new InvalidOperationException(
                            $"Key property '{keyProperty.Name}' cannot be empty for entity type '{typeof(T).Name}'");
                    }
                }
            }
        }

        public override string ToString()
        {
            var topicName = GetTopicName();
            var entityName = typeof(T).Name;
            return $"EventSetCore<{entityName}> â†’ Topic: {topicName}";
        }

        // æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆä»–ã®éƒ¨åˆ†ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ï¼‰
        public abstract List<T> ToList();
        public abstract Task<List<T>> ToListAsync(CancellationToken cancellationToken = default);
        public abstract string ToKsql(bool isPullQuery = false);
        public abstract void Subscribe(Action<T> onNext, CancellationToken cancellationToken = default);
        public abstract Task SubscribeAsync(Func<T, Task> onNext, CancellationToken cancellationToken = default);
        public abstract Task ForEachAsync(Func<T, Task> action, TimeSpan timeout = default, CancellationToken cancellationToken = default);
        public abstract IEventSet<T> Where(Expression<Func<T, bool>> predicate);
        public abstract IEventSet<TResult> Select<TResult>(Expression<Func<T, TResult>> selector);
        public abstract IEventSet<IGrouping<TKey, T>> GroupBy<TKey>(Expression<Func<T, TKey>> keySelector);
        public abstract IEventSet<T> Take(int count);
        public abstract IEventSet<T> Skip(int count);
    }
}
```

### 4ï¸âƒ£ EventSetså±¤ - Streaming & Validationåˆ†å‰²

```csharp
// src/Query/EventSets/EventSetStreaming.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;
using KsqlDsl.Query.Abstractions;
using KsqlDsl.Query.Translation;

namespace KsqlDsl.Query.EventSets
{
    /// <summary>
    /// EventSet Push/Pullå‹æ“ä½œã€EMITåˆ¶å¾¡
    /// è¨­è¨ˆç†ç”±ï¼šã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°é–¢é€£è²¬å‹™ã®åˆ†é›¢
    /// </summary>
    public partial class EventSetStreaming<T> : EventSetCore<T> where T : class
    {
        private readonly IQueryTranslator _queryTranslator;
        
        internal EventSetStreaming(KafkaContext context, EntityModel entityModel) 
            : base(context, entityModel)
        {
            _queryTranslator = new QueryTranslator();
        }

        internal EventSetStreaming(KafkaContext context, EntityModel entityModel, Expression expression) 
            : base(context, entityModel, expression)
        {
            _queryTranslator = new QueryTranslator();
        }

        // Pull Queryå®Ÿè¡Œï¼ˆToListç³»ï¼‰
        public override List<T> ToList()
        {
            var topicName = GetTopicName();
            
            ValidateQueryBeforeExecution();
            
            // Pull Queryã¨ã—ã¦å®Ÿè¡Œï¼ˆisPullQuery: trueï¼‰
            var ksqlQuery = ToKsql(isPullQuery: true);

            if (_context.Options.EnableDebugLogging)
            {
                Console.WriteLine($"[DEBUG] EventSetStreaming.ToList: {typeof(T).Name} â† Topic: {topicName}");
                Console.WriteLine($"[DEBUG] Generated KSQL: {ksqlQuery}");
                Console.WriteLine($"[DEBUG] Query Diagnostics: {_queryTranslator.GetDiagnostics()}");
            }

            var consumerService = _context.GetConsumerService();

            try
            {
                ValidateKsqlQuery(ksqlQuery);
                var results = consumerService.Query<T>(ksqlQuery, _entityModel);
                ValidateQueryResults(results);

                if (_context.Options.EnableDebugLogging)
                {
                    Console.WriteLine($"[DEBUG] Query completed successfully. Results: {results.Count} items");
                }

                return results;
            }
            catch (Exception ex)
            {
                HandleQueryException(ex, topicName, "ToList");
                throw;
            }
        }

        public override async Task<List<T>> ToListAsync(CancellationToken cancellationToken = default)
        {
            var topicName = GetTopicName();
            
            ValidateQueryBeforeExecution();
            
            var ksqlQuery = ToKsql(isPullQuery: true);

            if (_context.Options.EnableDebugLogging)
            {
                Console.WriteLine($"[DEBUG] EventSetStreaming.ToListAsync: {typeof(T).Name} â† Topic: {topicName}");
                Console.WriteLine($"[DEBUG] Generated KSQL: {ksqlQuery}");
            }

            var consumerService = _context.GetConsumerService();

            try
            {
                ValidateKsqlQuery(ksqlQuery);
                var results = await consumerService.QueryAsync<T>(ksqlQuery, _entityModel, cancellationToken);
                ValidateQueryResults(results);

                return results;
            }
            catch (OperationCanceledException)
            {
                if (_context.Options.EnableDebugLogging)
                {
                    Console.WriteLine($"[DEBUG] Query cancelled by CancellationToken");
                }
                throw;
            }
            catch (Exception ex)
            {
                HandleQueryException(ex, topicName, "ToListAsync");
                throw;
            }
        }

        // Push Queryå®Ÿè¡Œï¼ˆSubscribeç³»ï¼‰
        public override void Subscribe(Action<T> onNext, CancellationToken cancellationToken = default)
        {
            if (onNext == null)
                throw new ArgumentNullException(nameof(onNext));

            var topicName = GetTopicName();
            if (_context.Options.EnableDebugLogging)
            {
                Console.WriteLine($"[DEBUG] EventSetStreaming.Subscribe: {typeof(T).Name} â† Topic: {topicName} (Pushå‹è³¼èª­é–‹å§‹)");
            }
        }

        public override async Task SubscribeAsync(Func<T, Task> onNext, CancellationToken cancellationToken = default)
        {
            if (onNext == null)
                throw new ArgumentNullException(nameof(onNext));

            await Task.Delay(1, cancellationToken);

            var topicName = GetTopicName();
            if (_context.Options.EnableDebugLogging)
            {
                Console.WriteLine($"[DEBUG] EventSetStreaming.SubscribeAsync: {typeof(T).Name} â† Topic: {topicName} (éåŒæœŸPushå‹è³¼èª­é–‹å§‹)");
            }
        }

        public override async Task ForEachAsync(Func<T, Task> action, TimeSpan timeout = default, CancellationToken cancellationToken = default)
        {
            if (action == null)
                throw new ArgumentNullException(nameof(action));

            var topicName = GetTopicName();
            var timeoutMs = timeout == TimeSpan.Zero ? int.MaxValue : (int)timeout.TotalMilliseconds;

            // Push Queryï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å–å¾—ï¼‰å°‚ç”¨
            var ksqlQuery = ToKsql(isPullQuery: false);

            if (_context.Options.EnableDebugLogging)
            {
                Console.WriteLine($"[DEBUG] EventSetStreaming.ForEachAsync: {typeof(T).Name} â† Topic: {topicName} (Pushå‹ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°é–‹å§‹)");
                Console.WriteLine($"[DEBUG] Generated KSQL: {ksqlQuery}");
                Console.WriteLine($"[DEBUG] Timeout: {timeoutMs}ms");
            }

            ValidateQueryBeforeExecution();

            var consumerService = _context.GetConsumerService();

            CancellationTokenSource? timeoutCts = null;
            CancellationToken effectiveToken = cancellationToken;

            if (timeoutMs != int.MaxValue)
            {
                timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
                timeoutCts.CancelAfter(timeoutMs);
                effectiveToken = timeoutCts.Token;
            }

            try
            {
                await consumerService.SubscribeStreamAsync<T>(
                    ksqlQuery,
                    _entityModel,
                    async (item) =>
                    {
                        if (effectiveToken.IsCancellationRequested)
                            return;

                        await action(item);
                    },
                    effectiveToken);

                if (_context.Options.EnableDebugLogging)
                {
                    Console.WriteLine($"[DEBUG] ForEachAsync streaming completed for {typeof(T).Name}");
                }
            }
            catch (OperationCanceledException ex) when (timeoutCts?.Token.IsCancellationRequested == true && !cancellationToken.IsCancellationRequested)
            {
                if (_context.Options.EnableDebugLogging)
                {
                    Console.WriteLine($"[DEBUG] ForEachAsync streaming timeout after {timeoutMs}ms for {typeof(T).Name}");
                }
                throw new TimeoutException($"ForEachAsync operation timed out after {timeoutMs}ms", ex);
            }
            catch (Exception ex)
            {
                HandleQueryException(ex, topicName, "ForEachAsync");
                throw;
            }
            finally
            {
                timeoutCts?.Dispose();
            }
        }

        // KSQLå¤‰æ›ï¼ˆãƒ•ãƒ©ã‚°åˆ¶å¾¡ç‰ˆï¼‰
        public override string ToKsql(bool isPullQuery = false)
        {
            try
            {
                var topicName = GetTopicName();
                return _queryTranslator.ToKsql(_expression, topicName, isPullQuery);
            }
            catch (Exception ex)
            {
                if (_context.Options.EnableDebugLogging)
                {
                    Console.WriteLine($"[DEBUG] KSQLå¤‰æ›ã‚¨ãƒ©ãƒ¼: {ex.Message}");
                    Console.WriteLine($"[DEBUG] Expression: {_expression}");
                }
                return $"/* KSQLå¤‰æ›ã‚¨ãƒ©ãƒ¼: {ex.Message} */";
            }
        }

        // LINQ Extensions - æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™
        public override IEventSet<T> Where(Expression<Func<T, bool>> predicate)
        {
            if (predicate == null)
                throw new ArgumentNullException(nameof(predicate));

            var methodCall = Expression.Call(
                typeof(Queryable),
                nameof(Queryable.Where),
                new[] { typeof(T) },
                _expression,
                Expression.Quote(predicate));

            return new EventSetStreaming<T>(_context, _entityModel, methodCall);
        }

        public override IEventSet<TResult> Select<TResult>(Expression<Func<T, TResult>> selector)
        {
            if (selector == null)
                throw new ArgumentNullException(nameof(selector));

            var methodCall = Expression.Call(
                typeof(Queryable),
                nameof(Queryable.Select),
                new[] { typeof(T), typeof(TResult) },
                _expression,
                Expression.Quote(selector));

            return new EventSetStreaming<TResult>(_context, _entityModel, methodCall);
        }

        public override IEventSet<IGrouping<TKey, T>> GroupBy<TKey>(Expression<Func<T, TKey>> keySelector)
        {
            if (keySelector == null)
                throw new ArgumentNullException(nameof(keySelector));

            var methodCall = Expression.Call(
                typeof(Queryable),
                nameof(Queryable.GroupBy),
                new[] { typeof(T), typeof(TKey) },
                _expression,
                Expression.Quote(keySelector));

            return new EventSetStreaming<IGrouping<TKey, T>>(_context, _entityModel, methodCall);
        }

        public override IEventSet<T> Take(int count)
        {
            if (count <= 0)
                throw new ArgumentException("Count must be positive", nameof(count));

            var methodCall = Expression.Call(
                typeof(Queryable),
                nameof(Queryable.Take),
                new[] { typeof(T) },
                _expression,
                Expression.Constant(count));

            return new EventSetStreaming<T>(_context, _entityModel, methodCall);
        }

        public override IEventSet<T> Skip(int count)
        {
            if (count < 0)
                throw new ArgumentException("Count cannot be negative", nameof(count));

            var methodCall = Expression.Call(
                typeof(Queryable),
                nameof(Queryable.Skip),
                new[] { typeof(T) },
                _expression,
                Expression.Constant(count));

            return new EventSetStreaming<T>(_context, _entityModel, methodCall);
        }

        // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
        private void ValidateKsqlQuery(string ksqlQuery)
        {
            if (string.IsNullOrEmpty(ksqlQuery) || ksqlQuery.Contains("/* KSQLå¤‰æ›ã‚¨ãƒ©ãƒ¼"))
            {
                throw new InvalidOperationException($"Failed to generate valid KSQL query for {typeof(T).Name}");
            }
        }

        private void HandleQueryException(Exception ex, string topicName, string operation)
        {
            if (_context.Options.EnableDebugLogging)
            {
                Console.WriteLine($"[DEBUG] {operation} error: {ex.Message}");
            }

            if (ex is KafkaConsumerException)
            {
                throw new InvalidOperationException(
                    $"Failed to execute {operation} on topic '{topicName}' for {typeof(T).Name}: {ex.Message}", ex);
            }
            else
            {
                throw new InvalidOperationException(
                    $"Unexpected error in {operation} for {typeof(T).Name} from topic '{topicName}': {ex.Message}", ex);
            }
        }
    }
}

// src/Query/EventSets/EventSetValidation.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using KsqlDsl.Validation;

namespace KsqlDsl.Query.EventSets
{
    /// <summary>
    /// EventSetå‹æ¤œè¨¼ãƒ»Nullç¢ºèª
    /// è¨­è¨ˆç†ç”±ï¼šãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è²¬å‹™ã®åˆ†é›¢ã€Strictãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ
    /// </summary>
    public partial class EventSetValidation<T> : EventSetStreaming<T> where T : class
    {
        internal EventSetValidation(KafkaContext context, EntityModel entityModel) 
            : base(context, entityModel) { }

        internal EventSetValidation(KafkaContext context, EntityModel entityModel, Expression expression) 
            : base(context, entityModel, expression) { }

        /// <summary>
        /// ã‚¯ã‚¨ãƒªå®Ÿè¡Œå‰ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å¼·åŒ–ç‰ˆ
        /// </summary>
        protected override void ValidateQueryBeforeExecution()
        {
            // åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            base.ValidateQueryBeforeExecution();

            // EntityModelãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            if (_entityModel == null)
            {
                throw new InvalidOperationException($"EntityModel is not configured for {typeof(T).Name}");
            }

            if (!_entityModel.IsValid)
            {
                var errors = _entityModel.ValidationResult?.Errors ?? new List<string> { "Unknown validation error" };
                throw new InvalidOperationException(
                    $"EntityModel validation failed for {typeof(T).Name}: {string.Join("; ", errors)}");
            }

            // Expression ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            if (_expression == null)
            {
                throw new InvalidOperationException($"Query expression is null for {typeof(T).Name}");
            }

            // æœªã‚µãƒãƒ¼ãƒˆæ“ä½œãƒã‚§ãƒƒã‚¯å¼·åŒ–
            try
            {
                CheckForUnsupportedOperations(_expression);
            }
            catch (NotSupportedException ex)
            {
                throw new NotSupportedException(
                    $"Unsupported LINQ operation detected in query for {typeof(T).Name}: {ex.Message}", ex);
            }

            // Strictãƒ¢ãƒ¼ãƒ‰æ™‚ã®è¿½åŠ ãƒã‚§ãƒƒã‚¯
            if (_context.Options.ValidationMode == ValidationMode.Strict)
            {
                ValidateStrictModeRequirements();
            }
        }

        /// <summary>
        /// ã‚¯ã‚¨ãƒªçµæœå¾Œå‡¦ç†ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å¼·åŒ–ç‰ˆ
        /// </summary>
        protected void ValidateQueryResults(List<T> results)
        {
            if (results == null)
            {
                throw new InvalidOperationException($"Query returned null results for {typeof(T).Name}");
            }

            // Strictãƒ¢ãƒ¼ãƒ‰æ™‚ã®è¿½åŠ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            if (_context.Options.ValidationMode == ValidationMode.Strict)
            {
                foreach (var result in results)
                {
                    if (result == null)
                    {
                        throw new InvalidOperationException(
                            $"Query returned null entity in results for {typeof(T).Name}");
                    }

                    ValidateEntityStrict(result);
                }
            }
        }

        /// <summary>
        /// ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ‹¡å¼µç‰ˆ
        /// </summary>
        protected override void ValidateEntity(T entity)
        {
            base.ValidateEntity(entity);

            // Strictãƒ¢ãƒ¼ãƒ‰æ™‚ã®è¿½åŠ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            if (_context.Options.ValidationMode == ValidationMode.Strict)
            {
                ValidateEntityStrict(entity);
            }
        }

        /// <summary>
        /// Strictãƒ¢ãƒ¼ãƒ‰ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        /// </summary>
        private void ValidateEntityStrict(T entity)
        {
            var entityType = typeof(T);
            var properties = entityType.GetProperties();

            foreach (var property in properties)
            {
                var value = property.GetValue(entity);

                // MaxLength validation for string properties
                var maxLengthAttr = property.GetCustomAttribute<KsqlDsl.Attributes.MaxLengthAttribute>();
                if (maxLengthAttr != null && value is string stringValue)
                {
                    if (stringValue.Length > maxLengthAttr.Length)
                    {
                        throw new InvalidOperationException(
                            $"Property '{property.Name}' exceeds maximum length of {maxLengthAttr.Length}. Current length: {stringValue.Length}");
                    }
                }

                // Required property validation
                if (IsRequiredProperty(property) && value == null)
                {
                    throw new InvalidOperationException(
                        $"Required property '{property.Name}' cannot be null for entity type '{entityType.Name}'");
                }

                // Type compatibility validation
                ValidatePropertyTypeCompatibility(property, value);
            }
        }

        /// <summary>
        /// æœªã‚µãƒãƒ¼ãƒˆæ“ä½œãƒã‚§ãƒƒã‚¯
        /// </summary>
        private void CheckForUnsupportedOperations(Expression expression)
        {
            var visitor = new UnsupportedOperationVisitor();
            visitor.Visit(expression);
        }

        /// <summary>
        /// Strictãƒ¢ãƒ¼ãƒ‰è¦ä»¶ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        /// </summary>
        private void ValidateStrictModeRequirements()
        {
            // ã‚¹ã‚­ãƒ¼ãƒæ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
            ValidateSchemaConsistency();

            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è­¦å‘Šãƒã‚§ãƒƒã‚¯
            ValidatePerformanceImpact();
        }

        /// <summary>
        /// ã‚¹ã‚­ãƒ¼ãƒæ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
        /// </summary>
        private void ValidateSchemaConsistency()
        {
            var entityType = typeof(T);
            var properties = entityType.GetProperties();

            // å…¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
            foreach (var property in properties)
            {
                if (property.GetCustomAttribute<KsqlDsl.Modeling.KafkaIgnoreAttribute>() != null)
                    continue;

                if (!IsSerializableType(property.PropertyType))
                {
                    throw new InvalidOperationException(
                        $"Property '{property.Name}' of type '{property.PropertyType.Name}' is not serializable in Avro schema for {entityType.Name}");
                }
            }
        }

        /// <summary>
        /// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å½±éŸ¿ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        /// </summary>
        private void ValidatePerformanceImpact()
        {
            // è¤‡é›‘ãªã‚¯ã‚¨ãƒªã®è­¦å‘Š
            var complexityScore = CalculateQueryComplexity(_expression);
            if (complexityScore > 10)
            {
                if (_context.Options.EnableDebugLogging)
                {
                    Console.WriteLine($"[WARNING] High query complexity detected (score: {complexityScore}) for {typeof(T).Name}");
                }
            }
        }

        /// <summary>
        /// ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå¿…é ˆã‹ã©ã†ã‹ã®åˆ¤å®š
        /// </summary>
        private bool IsRequiredProperty(PropertyInfo property)
        {
            // ã‚­ãƒ¼ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯å¿…é ˆ
            if (property.GetCustomAttribute<KsqlDsl.Attributes.KeyAttribute>() != null)
                return true;

            // Nullableå‹ã¯éå¿…é ˆ
            if (Nullable.GetUnderlyingType(property.PropertyType) != null)
                return false;

            // å‚ç…§å‹ã®nullè¨±å¯çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
            if (!property.PropertyType.IsValueType)
            {
                try
                {
                    var nullabilityContext = new NullabilityInfoContext();
                    var nullabilityInfo = nullabilityContext.Create(property);
                    return nullabilityInfo.WriteState == NullabilityState.NotNull;
                }
                catch
                {
                    return false; // Nullable contextå–å¾—å¤±æ•—æ™‚ã¯éå¿…é ˆæ‰±ã„
                }
            }

            return true; // å€¤å‹ã¯åŸºæœ¬çš„ã«å¿…é ˆ
        }

        /// <summary>
        /// ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å‹äº’æ›æ€§ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        /// </summary>
        private void ValidatePropertyTypeCompatibility(PropertyInfo property, object? value)
        {
            if (value == null) return;

            var expectedType = property.PropertyType;
            var actualType = value.GetType();

            if (!expectedType.IsAssignableFrom(actualType))
            {
                throw new InvalidOperationException(
                    $"Property '{property.Name}' expected type '{expectedType.Name}' but got '{actualType.Name}'");
            }
        }

        /// <summary>
        /// ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºå¯èƒ½å‹åˆ¤å®š
        /// </summary>
        private bool IsSerializableType(Type type)
        {
            var underlyingType = Nullable.GetUnderlyingType(type) ?? type;

            return underlyingType.IsPrimitive ||
                   underlyingType == typeof(string) ||
                   underlyingType == typeof(decimal) ||
                   underlyingType == typeof(DateTime) ||
                   underlyingType == typeof(DateTimeOffset) ||
                   underlyingType == typeof(Guid) ||
                   underlyingType == typeof(byte[]) ||
                   underlyingType.IsEnum;
        }

        /// <summary>
        /// ã‚¯ã‚¨ãƒªè¤‡é›‘åº¦è¨ˆç®—
        /// </summary>
        private int CalculateQueryComplexity(Expression expression)
        {
            var visitor = new ComplexityCalculatorVisitor();
            visitor.Visit(expression);
            return visitor.ComplexityScore;
        }

        /// <summary>
        /// æœªã‚µãƒãƒ¼ãƒˆæ“ä½œæ¤œå‡ºVisitor
        /// </summary>
        private class UnsupportedOperationVisitor : ExpressionVisitor
        {
            protected override Expression VisitMethodCall(MethodCallExpression node)
            {
                var methodName = node.Method.Name;

                switch (methodName)
                {
                    case "OrderBy":
                    case "OrderByDescending":
                    case "ThenBy":
                    case "ThenByDescending":
                        throw new NotSupportedException($"ORDER BY operations are not supported in ksqlDB: {methodName}");

                    case "Distinct":
                        throw new NotSupportedException("DISTINCT operations are not supported in ksqlDB");

                    case "Union":
                    case "Intersect":
                    case "Except":
                        throw new NotSupportedException($"Set operations are not supported in ksqlDB: {methodName}");
                }

                return base.VisitMethodCall(node);
            }
        }

        /// <summary>
        /// ã‚¯ã‚¨ãƒªè¤‡é›‘åº¦è¨ˆç®—Visitor
        /// </summary>
        private class ComplexityCalculatorVisitor : ExpressionVisitor
        {
            public int ComplexityScore { get; private set; } = 0;

            protected override Expression VisitMethodCall(MethodCallExpression node)
            {
                var methodName = node.Method.Name;

                // ãƒ¡ã‚½ãƒƒãƒ‰ç¨®åˆ¥ã«ã‚ˆã‚‹è¤‡é›‘åº¦åŠ ç®—
                switch (methodName)
                {
                    case "Where":
                        ComplexityScore += 1;
                        break;
                    case "Select":
                        ComplexityScore += 1;
                        break;
                    case "GroupBy":
                        ComplexityScore += 3;
                        break;
                    case "Join":
                        ComplexityScore += 5;
                        break;
                    case "Sum":
                    case "Count":
                    case "Max":
                    case "Min":
                    case "Average":
                        ComplexityScore += 2;
                        break;
                    default:
                        ComplexityScore += 1;
                        break;
                }

                return base.VisitMethodCall(node);
            }

            protected override Expression VisitBinary(BinaryExpression node)
            {
                ComplexityScore += 1;
                return base.VisitBinary(node);
            }
        }
    }
}

// src/Query/EventSets/EventSet.cs - çµ±åˆãƒ•ã‚¡ã‚µãƒ¼ãƒ‰
using KsqlDsl.Modeling;
using KsqlDsl.Query.Abstractions;
using System;
using System.Linq.Expressions;

namespace KsqlDsl.Query.EventSets
{
    /// <summary>
    /// EventSetçµ±åˆãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ - æ—¢å­˜APIã¨ã®äº’æ›æ€§ç¶­æŒ
    /// è¨­è¨ˆç†ç”±ï¼šåˆ†å‰²å¾Œã‚‚æ—¢å­˜ã‚³ãƒ¼ãƒ‰ãŒå‹•ä½œã™ã‚‹ã‚ˆã†äº’æ›æ€§ä¿æŒ
    /// </summary>
    public class EventSet<T> : EventSetValidation<T> where T : class
    {
        internal EventSet(KafkaContext context, EntityModel entityModel) 
            : base(context, entityModel) { }

        internal EventSet(KafkaContext context, EntityModel entityModel, Expression expression) 
            : base(context, entityModel, expression) { }

        // ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ - å°†æ¥çš„ã«ä»–ã®å®Ÿè£…ã«åˆ‡ã‚Šæ›¿ãˆå¯èƒ½
        public static EventSet<T> Create(KafkaContext context, EntityModel entityModel)
        {
            return new EventSet<T>(context, entityModel);
        }

        public static EventSet<T> Create(KafkaContext context, EntityModel entityModel, Expression expression)
        {
            return new EventSet<T>(context, entityModel, expression);
        }

        // å‹å¤‰æ›ãƒ¡ã‚½ãƒƒãƒ‰ - LINQ Extensionsç”¨
        protected override IEventSet<TResult> CreateEventSet<TResult>(Expression expression)
        {
            return new EventSet<TResult>(_context, _entityModel, expression);
        }

        protected override IEventSet<T> CreateEventSet(Expression expression)
        {
            return new EventSet<T>(_context, _entityModel, expression);
        }
    }
}
```

### 5ï¸âƒ£ Builderså±¤ - ãƒ“ãƒ«ãƒ€ãƒ¼çµ±åˆã¨å…±é€šIFå®Ÿè£…

```csharp
// src/Query/Builders/SelectBuilder.cs
using System;
using System.Linq.Expressions;
using KsqlDsl.Query.Abstractions;

namespace KsqlDsl.Query.Builders
{
    /// <summary>
    /// SELECTå¥æ§‹ç¯‰ãƒ“ãƒ«ãƒ€ãƒ¼
    /// è¨­è¨ˆç†ç”±ï¼šæ—¢å­˜KsqlConditionBuilderã®ç§»å‹•ãƒ»çµ±åˆ
    /// </summary>
    public class SelectBuilder : IKsqlBuilder
    {
        public KsqlBuilderType BuilderType => KsqlBuilderType.Where;

        public string Build(Expression expression)
        {
            var conditionBuilder = new KsqlDsl.Ksql.KsqlConditionBuilder();
            return conditionBuilder.Build(expression);
        }

        /// <summary>
        /// æ¡ä»¶ã®ã¿æ§‹ç¯‰ï¼ˆWHERE ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãªã—ï¼‰
        /// </summary>
        public string BuildCondition(Expression expression)
        {
            var conditionBuilder = new KsqlDsl.Ksql.KsqlConditionBuilder();
            return conditionBuilder.BuildCondition(expression);
        }
    }
}

// src/Query/Builders/JoinBuilder.cs  
using System;
using System.Linq.Expressions;
using KsqlDsl.Query.Abstractions;

namespace KsqlDsl.Query.Builders
{
    /// <summary>
    /// JOINå¥æ§‹ç¯‰ãƒ“ãƒ«ãƒ€ãƒ¼
    /// </summary>
    public class JoinBuilder : IKsqlBuilder
    {
        public KsqlBuilderType BuilderType => KsqlBuilderType.Join;

        public string Build(Expression expression)
        {
            var joinBuilder = new KsqlDsl.Ksql.KsqlJoinBuilder();
            return joinBuilder.Build(expression);
        }
    }
}

// src/Query/Builders/WindowBuilder.cs
using System;
using System.Linq.Expressions;
using KsqlDsl.Query.Abstractions;

namespace KsqlDsl.Query.Builders
{
    /// <summary>
    /// WINDOWå¥æ§‹ç¯‰ãƒ“ãƒ«ãƒ€ãƒ¼
    /// </summary>
    public class WindowBuilder : IKsqlBuilder
    {
        public KsqlBuilderType BuilderType => KsqlBuilderType.Window;

        public string Build(Expression expression)
        {
            var windowBuilder = new KsqlDsl.Ksql.KsqlWindowBuilder();
            return windowBuilder.Build(expression);
        }
    }
}

// src/Query/Builders/GroupByBuilder.cs
using System;
using System.Linq.Expressions;
using KsqlDsl.Query.Abstractions;

namespace KsqlDsl.Query.Builders
{
    /// <summary>
    /// GROUP BYå¥æ§‹ç¯‰ãƒ“ãƒ«ãƒ€ãƒ¼
    /// </summary>
    public class GroupByBuilder : IKsqlBuilder
    {
        public KsqlBuilderType BuilderType => KsqlBuilderType.GroupBy;

        public string Build(Expression expression)
        {
            return KsqlDsl.Ksql.KsqlGroupByBuilder.Build(expression);
        }
    }
}

// src/Query/Builders/HavingBuilder.cs
using System;
using System.Linq.Expressions;
using KsqlDsl.Query.Abstractions;

namespace KsqlDsl.Query.Builders
{
    /// <summary>
    /// HAVINGå¥æ§‹ç¯‰ãƒ“ãƒ«ãƒ€ãƒ¼
    /// </summary>
    public class HavingBuilder : IKsqlBuilder
    {
        public KsqlBuilderType BuilderType => KsqlBuilderType.Having;

        public string Build(Expression expression)
        {
            var havingBuilder = new KsqlDsl.Ksql.KsqlHavingBuilder();
            return havingBuilder.Build(expression);
        }
    }
}

// src/Query/Builders/ProjectionBuilder.cs
using System;
using System.Linq.Expressions;
using KsqlDsl.Query.Abstractions;

namespace KsqlDsl.Query.Builders
{
    /// <summary>
    /// å°„å½±ï¼ˆSELECTåˆ—ï¼‰æ§‹ç¯‰ãƒ“ãƒ«ãƒ€ãƒ¼
    /// </summary>
    public class ProjectionBuilder : IKsqlBuilder
    {
        public KsqlBuilderType BuilderType => KsqlBuilderType.Projection;

        public string Build(Expression expression)
        {
            var projectionBuilder = new KsqlDsl.Ksql.KsqlProjectionBuilder();
            return projectionBuilder.Build(expression);
        }
    }
}

// src/Query/Translation/QueryTranslator.cs - IQueryTranslatorå®Ÿè£…
using System;
using System.Linq.Expressions;
using KsqlDsl.Query.Abstractions;

namespace KsqlDsl.Query.Translation
{
    /// <summary>
    /// QueryTranslatorã®å®Ÿè£…ã‚¯ãƒ©ã‚¹
    /// è¨­è¨ˆç†ç”±ï¼šæ—¢å­˜LinqToKsqlTranslatorã‚’IQueryTranslatoræº–æ‹ ã§å†æ§‹ç¯‰
    /// </summary>
    public class QueryTranslator : IQueryTranslator
    {
        private readonly LinqExpressionAnalyzer _analyzer;
        private readonly KsqlQueryBuilder _queryBuilder;
        private readonly QueryDiagnostics _diagnostics;
        
        public QueryTranslator()
        {
            _analyzer = new LinqExpressionAnalyzer();
            _queryBuilder = new KsqlQueryBuilder();
            _diagnostics = new QueryDiagnostics();
        }

        public string ToKsql(Expression expression, string topicName, bool isPullQuery = false)
        {
            _diagnostics.LogStep("Translation started", new { TopicName = topicName, IsPullQuery = isPullQuery });
            _diagnostics.SetMetadata("TopicName", topicName);
            _diagnostics.SetMetadata("IsPullQuery", isPullQuery);

            try
            {
                // å¼æœ¨è§£æ
                _diagnostics.LogStep("Analyzing LINQ expression");
                var analysisResult = _analyzer.Analyze(expression);
                _diagnostics.SetMetadata("QueryType", analysisResult.QueryType);
                _diagnostics.LogStep("Analysis completed", analysisResult.QueryType);

                // KSQLæ§‹ç¯‰
                _diagnostics.LogStep("Building KSQL query");
                var ksqlQuery = _queryBuilder.BuildQuery(analysisResult, topicName, isPullQuery);
                _diagnostics.LogStep("KSQL built successfully", ksqlQuery.Length + " characters");

                _diagnostics.MarkComplete();
                return ksqlQuery;
            }
            catch (Exception ex)
            {
                _diagnostics.LogStep("Translation failed", ex.Message);
                _diagnostics.MarkComplete();
                throw;
            }
        }

        public string GetDiagnostics()
        {
            return _diagnostics.GenerateReport();
        }

        public bool IsPullQuery()
        {
            return _diagnostics._metadata.TryGetValue("IsPullQuery", out var value) && (bool)value;
        }
    }
}
```

## ğŸ“ æœ€çµ‚æˆæœç‰©æ§‹é€ 

```
src/Query/
â”œâ”€â”€ Abstractions/
â”‚   â”œâ”€â”€ IQueryTranslator.cs      âœ… å®Œäº†
â”‚   â”œâ”€â”€ IEventSet<T>.cs          âœ… å®Œäº†
â”‚   â””â”€â”€ IKsqlBuilder.cs          âœ… å®Œäº†
â”œâ”€â”€ Translation/
â”‚   â”œâ”€â”€ LinqExpressionAnalyzer.cs âœ… å®Œäº†
â”‚   â”œâ”€â”€ KsqlQueryBuilder.cs      âœ… å®Œäº†
â”‚   â”œâ”€â”€ QueryDiagnostics.cs      âœ… å®Œäº†
â”‚   â””â”€â”€ QueryTranslator.cs       âœ… å®Œäº†
â”œâ”€â”€ EventSets/
â”‚   â”œâ”€â”€ EventSetCore<T>.cs       âœ… å®Œäº†
â”‚   â”œâ”€â”€ EventSetStreaming<T>.cs  âœ… å®Œäº†
â”‚   â”œâ”€â”€ EventSetValidation<T>.cs âœ… å®Œäº†
â”‚   â””â”€â”€ EventSet<T>.cs           âœ… å®Œäº† (çµ±åˆãƒ•ã‚¡ã‚µãƒ¼ãƒ‰)
â””â”€â”€ Builders/
    â”œâ”€â”€ SelectBuilder.cs         âœ… å®Œäº†
    â”œâ”€â”€ JoinBuilder.cs           âœ… å®Œäº†
    â”œâ”€â”€ WindowBuilder.cs         âœ… å®Œäº†
    â”œâ”€â”€ GroupByBuilder.cs        âœ… å®Œäº†
    â”œâ”€â”€ HavingBuilder.cs         âœ… å®Œäº†
    â””â”€â”€ ProjectionBuilder.cs     âœ… å®Œäº†
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆã¸ã®å½±éŸ¿ã¨å¯¾å¿œ

æ—¢å­˜ã®ãƒ†ã‚¹ãƒˆã¨ã®äº’æ›æ€§ã‚’ä¿ã¤ãŸã‚ï¼š

1. **EventSet<T>ã¯çµ±åˆãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ã¨ã—ã¦æ®‹å­˜**
2. **åå‰ç©ºé–“ã¯æ®µéšçš„ç§»è¡Œ** (`using KsqlDsl;` â†’ `using KsqlDsl.Query.EventSets;`)
3. **æ—¢å­˜LinqToKsqlTranslatorã¯éæ¨å¥¨ãƒãƒ¼ã‚¯**ã§æ®µéšçš„ç§»è¡Œ
4. **ToKsqlTestsç­‰ã¯æ–°ã—ã„QueryTranslatorã§ã‚‚å‹•ä½œ**

## âœ… æ”¹å–„åŠ¹æœï¼ˆ